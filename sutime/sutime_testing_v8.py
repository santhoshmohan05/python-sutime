# -*- coding: utf-8 -*-
"""sutime_testing_v4_redo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-bmCPNkfvuEdlS2A2s_QBY7UhXhy521V
"""

import os
from os.path import dirname, abspath
import sys
sys.path.insert(1, dirname(abspath(__file__)))
from sutime import SUTime
import DateTimeExtraction.python_duckling_master.duckling as duckling
import json
import time
from datetime import datetime, timedelta
import calendar
import re
import pandas as pd

jar_files = dirname(abspath(__file__)) + '/jars'
# linux system
jll_loc = None
# MAC system
# jll_loc = "/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home/jre/lib/jli/libjli.dylib"
# windows system
# jll_loc = "C:/Program Files/Java/jre1.8.0_333/bin/server/jvm.dll"

sutime = SUTime(jars=jar_files, mark_time_ranges=True, jll_loc=jll_loc)
d = duckling.DucklingWrapper()

# V7.21
# TODO: Handle first and 3rd quarter of 2010 - Have to say 1st quarter and 3rd quarter

# TODO: Handle multiple weeks. Turn ind['W'] into list

def sutime_parse_intersect(su_time_output, input_columns, input_types, month_ref):
    sutime_value = [{'value': su_time_output}]
    print('Sutime INTERSECT value: ', sutime_value)
    if not sutime_value:
        return 'NAN'
    conditions = ''
    # Cleaning data passed into function
    intersect_split = [x.strip() for x in sutime_value[0]['value'].split('INTERSECT')]
    intersect_split = ' '.join(intersect_split)
    space_split = intersect_split.split(' ')
    #print('intersect_split: ', intersect_split)
    #print('space_split: ', space_split)
    space_split = [x.strip() for x in space_split]
    prev_flag = False
    this_flag = False
    c = calendar.Calendar()
    years = []
    backup_years = []
    months = []
    weeks = []
    # num_dict stores number of months, weeks, days, quarters. Questions such as revenue for first/last x months.
    num_dict = {'Y': 0, 'M': 0, 'W': 0, 'D': 0, 'Q': 0, 'YTHIS': 0,
                'YPREV': 0, 'MPREV': 0, 'WPREV': 0, 'QPREV': 0, 'DPREV': 0}

    # ind_dict stores indices of months ,quarters, weeks, days. Questions such as revenue for nth month of last year.
    ind_dict = {'Y': 0, 'Q': [], 'M': [], 'W': 0, 'D': 0}

    if 'date' in input_types:
        date_col = input_columns[input_types.index('date')]
    if 'month' in input_types:
        month_col = input_columns[input_types.index('month')]
    year_col = input_columns[input_types.index('year')]
    if 'day_name' in input_types:
        day_name_col = input_columns[input_types.index('day_name')]
    if 'quarter' in input_types:
        quarter_col = input_columns[input_types.index('quarter')]
    if 'week' in input_types:
        week_col = input_columns[input_types.index('week')]

    # Flag goes on when there is a range present in the sutime result
    range_flag = False

    # Flag goes on when there is a month range (January to March) present in the sutime result
    mrange_flag = False

    # Flag goes on when there is a month with day range (January 15 to March 27) present in the sutime result
    drange_flag = False

    # List fills with absolute dates mentioned. January 15, February 27, etc.
    absolute_dates = []

    # List fills with absolute dates mentioned. January 15, February 27, etc.
    absolute_date_ranges = []

    # Days of the week referenced
    days_of_week = []

    # Case where there is only 1 element in space separated list. Should be handled by date_conditions function
    # if len(space_split) == 1:
    #     #print('IF1')
    #     return 'NAN'
    for phrase in space_split:
        if phrase == 'RANGE':
            #print('IF2')
            range_flag = True
            continue
        if phrase == 'PREV' or phrase == 'PREV_IMMEDIATE' or phrase == 'PAST_REF':
            #print('IF3')
            prev_flag = True
            continue
        if phrase == 'THIS' or phrase == 'PRESENT_REF':
            #print('IF4')
            this_flag = True
            continue
        if phrase == 'MRANGE':
            mrange_flag = True
            continue
        if phrase == 'DRANGE':
            drange_flag = True
            continue

        # If month range is detected on previous phrase, append all months in range to list
        if mrange_flag:
            to_split = phrase.split('TO')
            for month in range(int(to_split[0]), int(to_split[1])+1):
                ind_dict['M'].append(month)
            mrange_flag = False

        # If absolute date range is detected on previous phrase, append date range as a tuple to list
        if drange_flag:
            to_split = phrase.split('TO')
            absolute_date_ranges.append((to_split[0], to_split[1]))
            drange_flag = False

        # If year is detected, add to list
        if len(phrase) == 4 and phrase.isdigit():
            #print('IF5')
            years.append(int(phrase))

        # If year range is detected, add all years in range to list
        if range_flag:
            #print('IF6')
            to_split = phrase.split('TO')
            year1 = int(to_split[0])
            year2 = int(to_split[1])
            if year1 >= year2:
                years.extend(list(range(year1, year2-1, -1)))
            elif year1 < year2:
                years.extend(list(range(year2, year1-1, -1)))
            range_flag = False

        # Handles formats like P2M, P2Y, PREV P2Y etc...
        if phrase[0] == 'P' and len(phrase) >= 3 and '#' not in phrase:
            #print('IF7')
            # Format such as PXM detected. Return
            if phrase[1] == 'X':
                #print('IF8')
                return 'NAN'
            if prev_flag:
                #print('IF9')
                num_dict[phrase[-1] + 'PREV'] = re.search(r'\d+', phrase).group()
                prev_flag = False
            elif this_flag:
                #print('IF10')
                num_dict[phrase[-1] + 'THIS'] = re.search(r'\d+', phrase).group()
                this_flag = False
            else:
                #print('IF11')
                #num_dict[phrase[2]] = phrase[1]
                num_dict[phrase[-1]] = re.search(r'\d+', phrase).group()

        # Handles format like P1M-#1, P2W-#2, etc...
        if phrase[0] == 'P' and 3 < len(phrase) < 8 and '#' in phrase:
            #print('IF12')
            dash_split = phrase.split('-')
            hash_split = phrase.split('#')
            #num_dict[dash_split[0][-1]] = dash_split[0][-2]
            if 'M' in phrase:
                #print('IF13')
                ind_dict[dash_split[0][-1]].append(int(hash_split[1]))
            else:
                ind_dict[dash_split[0][-1]] = hash_split[1]
        # Handles whenever quarter is present in text
        elif 'Q' in phrase and len(phrase) == 7:
            #print('IF14')
            ind_dict['Q'].append(phrase)
            dash_split = phrase.split('-')
            if dash_split[0] != 'XXXX' and dash_split[0].isdigit():
                years.append(int(dash_split[0]))
        elif 'Q' in phrase and len(phrase) > 7:
            #print('IF15')
            dash_split = phrase.split('-')
            # if len(dash_split) == 3 and 'Q' in dash_split[1] and 'W' not in dash_split[2]:
            #     print()
                #months.append(dash_split[2])
        elif 'W' in phrase and len(phrase) == 8:
            # Add week number to indices
            dash_split = phrase.split('-')
            if len(dash_split) == 2 and 'W' == dash_split[1][0] and dash_split[1][1:].isdigit():
                ind_dict['W'] = int(dash_split[1][1:])
            if len(dash_split[0]) == 4 and dash_split[0].isdigit():
                years.append(int(dash_split[0]))

        elif 'W' in phrase and (len(phrase) > 9 or len(phrase) == 7):
            # Find case where len(phrase) > 9 and add to ind_dict['W']
            # print('IF16')
            dash_split = phrase.split('-')
            if len(dash_split) == 3:
                if dash_split[0].isdigit() and len(dash_split[0]) == 4:
                    years.append(int(dash_split[0]))
                if dash_split[1] == 'WXX':
                    if dash_split[2].isdigit() and len(dash_split[2]) == 1:
                        days_of_week.append(int(dash_split[2]))
            if len(dash_split) == 3 and 'W' in dash_split[2] and 'X' not in dash_split[2]:
                weeks.append(dash_split[2].replace('W', ''))
            if len(dash_split) == 2:
                if dash_split[0].isdigit() and len(dash_split[0]) == 4:
                    years.append(int(dash_split[0]))
                if dash_split[1] == 'WE':
                    days_of_week.extend([6,7])
                if dash_split[1] == 'WD':
                    days_of_week.extend(list(range(1,6)))
        elif len(phrase) == 7:
            #print('IF17')
            dash_split = phrase.split('-')
            if dash_split[0] != 'XXXX' and dash_split[0] == datetime.now().year:
                backup_years.append(dash_split[0])
            elif dash_split[0] != 'XXXX':
                years.append(int(dash_split[0]))
            if dash_split[1].isdigit():
                ind_dict['M'].append(int(dash_split[1]))
        elif len(phrase) == 10:
            dash_split = phrase.split('-')
            if len(dash_split) == 3:
                if dash_split[1].isdigit() and dash_split[2].isdigit():
                    absolute_dates.append(dash_split[1]+'-'+dash_split[2])

    #print('Num Dict: ', num_dict)
    #print('Ind Dict: ', ind_dict)
    #print('Quarter: ', ind_dict['Q'])
    # print(num_dict)
    # print(ind_dict)
    # Fills list of years with associated years
    if num_dict['YTHIS'] != 0:
        years = [datetime.now().year]
    elif num_dict['YPREV'] != 0:
        years.extend(list(range(datetime.now().year-1, datetime.now().year - (int(num_dict['YPREV'])+1), -1)))
    elif ind_dict['Q'] != [] and not years:
        years = backup_years.copy()

    fill_year = True
    if month_ref:
        fill_year = False
    
    # Use current year if no year provided
    if not years and not days_of_week and fill_year:
        years.append(datetime.now().year)
    #print(years)
    # Remove duplicate years
    years = list(set(years))
    years.sort()
    #print('Years', years)
    #print('Weeks', ind_dict['Q'])
    #print('Months', months)
    #print('Weeks', weeks)
    #print('Absolute Dates', absolute_dates)
    #print('Absolute date ranges', absolute_date_ranges)
    #print('Num Dict: ', num_dict)
    #print('Ind Dict: ', ind_dict)

    # Handle absolute date ranges (January 15 to March 18) and absolute dates (January 15th for 2017 and 2019)
    if absolute_date_ranges:
        for year in years:
            for rng in absolute_date_ranges:
                from_date = str(year) + '-' + rng[0]
                to_date = str(year) + '-' + rng[1]
                conditions += '(' + date_col + ' BETWEEN \'' + from_date + '\' AND \'' + to_date + '\') OR '
        conditions = conditions[:-4]
        return conditions
    elif absolute_dates:
        for year in years:
            for date in absolute_dates:
                conditions += '(' + date_col + ' = \'' + (str(year) + '-' + date) + '\') OR '
        conditions = conditions[:-4]
        return conditions

    #print('Years: ',years)
    #print('Days: ',days_of_week)

    if days_of_week:
        week_days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
        conditions += '('
        for day in days_of_week:
            conditions += day_name_col + ' = \'' + week_days[day - 1] + '\' OR '
        conditions = conditions[:-4]
        conditions += ')'
        if years:
            conditions += ' AND ('
            for year in years:
                conditions += year_col + ' = \'' + str(year) + '\' OR '
            conditions = conditions[:-4] + ')'
        return conditions

    # Checking whether any absolute month indices are referenced.
    no_indices = True
    for key in ind_dict:
        if ind_dict[key]:
            no_indices = False
            break
    #print('No indices: ', no_indices)

    if no_indices:
        if num_dict['QPREV'] != 0:
            if len(years) == 1 and years[0] == datetime.now().year:
                # Last n quarters (of current year) - Should be handled by duckling
                return 'NAN'
            else:
                # Last n quarters of [years] (Past years)
                if datetime.now().year in years:
                    years.remove(datetime.now().year)
                end_q = 4
                start_q = end_q - int(num_dict['QPREV']) + 1

                if end_q == start_q:
                    conditions = '(' + quarter_col + ' = \'' + str(end_q) + \
                                  '\') AND ('
                else:
                    conditions = '(' + quarter_col + ' BETWEEN \'' + str(start_q) + '\' AND \'' + str(end_q) + \
                                  '\') AND ('

                for year in years:
                    conditions += year_col + ' = \'' + str(year) + '\' OR '

                conditions = conditions[:-4]
                conditions += ')'
                return conditions

        elif num_dict['MPREV'] != 0:
            if len(years) == 1 and years[0] == datetime.now().year:
                # Last n months (of current year) - Should be handled by duckling
                return 'NAN'
            else:
                # Last n months of [years] (Past years)
                #print('PREV Month')
                if datetime.now().year in years:
                    years.remove(datetime.now().year)
                end_month = 12
                start_month = end_month - int(num_dict['MPREV']) + 1

                if end_month == start_month:
                    conditions += '(' + month_col + ' = \'' + str(end_month) + \
                                  '\') AND ('
                else:
                    conditions += '(' + month_col + ' BETWEEN \'' + str(start_month) + '\' AND \'' + \
                                  str(end_month) + '\') AND ('

                for year in years:
                    conditions += year_col + ' = \'' + str(year) + '\' OR '

                conditions = conditions[:-4]
                conditions += ')'
                return conditions

        elif num_dict['WPREV'] != 0:
            if len(years) == 1 and years[0] == datetime.now().year:
                # Last n weeks(of current year) - Should be handled by duckling
                return 'NAN'
            else:
                # Last n weeks of [years] (Past years)
                #print('PREV Week')
                if datetime.now().year in years:
                    years.remove(datetime.now().year)
                end_w = 52
                start_w = end_w - int(num_dict['WPREV']) + 1

                if end_w == start_w:
                    conditions += '(' + week_col + ' = \'' + str(end_w) + \
                                  '\') AND ('
                else:
                    conditions += '(' + week_col + ' BETWEEN \'' + str(start_w) + '\' AND \'' + \
                                  str(end_w) + '\') AND ('

                for year in years:
                    conditions += year_col + ' = \'' + str(year) + '\' OR '

                conditions = conditions[:-4]
                conditions += ')'
                return conditions

        elif num_dict['DPREV'] != 0:
            if len(years) == 1 and years[0] == datetime.now().year:
                # Last n days (of current year) - Should be handled by duckling
                return 'NAN'
            else:
                # Last n days of [years] (Past years)
                #print('PREV Days')
                if datetime.now().year in years:
                    years.remove(datetime.now().year)
                for year in years:
                    num_days = int(num_dict['DPREV'])
                    last_date = datetime(year, 12, 31)
                    first_date = last_date - timedelta(days=num_days-1)
                    from_date = datetime.strftime(first_date, '%Y-%m-%d')
                    to_date = datetime.strftime(last_date, '%Y-%m-%d')
                    conditions += '(' + date_col + ' BETWEEN \'' + from_date + '\' AND \'' + to_date + '\') OR '
                conditions = conditions[:-4]
                return conditions


    # Handle cases like:
    # What is revenue in first n months of YYYY.
    # What is revenue in first n days of first n months of YYYY.
    if no_indices:
        if num_dict['Q']:
            if num_dict['M']:
                if num_dict['W']:
                    if num_dict['D']:
                        # Q, M, W, D
                        # print('Reached first n days of first n weeks of '
                        #       'first n months of first n quarters of [years]. TO IMPLEMENT')
                        return 'NAN'
                    else:
                        # Q, M, W
                        # print('Reached first n weeks of first n months of first n quarters of [years]. TO IMPLEMENT')
                        return 'NAN'
                else:
                    if num_dict['D'] != 0:
                        # Q, M, D
                        # print('Reached first n days of first n months of first n quarters of [years]. TO IMPLEMENT')
                        return 'NAN'
                    else:
                        # Q, M
                        # First n months of first n quarters of [years]
                        #print('IF-F1')
                        num_q = int(num_dict['Q'])
                        num_m = int(num_dict['M'])
                        months = []
                        for q in range(1, num_q+1):
                            for m in range(1, num_m+1):
                                months.append(q*3-3+m)

                        for m in months:
                            conditions += '(' + month_col + ' = \'' + str(m) + '\' OR '
                        conditions = conditions[:-4]
                        conditions += ') AND ('
                        for year in years:
                            conditions += year_col + ' = \'' + str(year) + '\' OR '

                        conditions = conditions[:-4]
                        conditions += ')'
                        return conditions
            else:
                if num_dict['W'] != 0:
                    if num_dict['D'] != 0:
                        # Q, W, D
                        #print('Reached first n days of first n weeks of first n quarters of [years]. TO IMPLEMENT')
                        return 'NAN'
                    else:
                        # Q, W
                        # TODO: Convert to week col
                        # First n weeks of first n quarters of [years]
                        #print('IF-F2')
                        num_days = int(num_dict['Q'])
                        num_weeks = int(num_dict['W'])
                        quarter_dates = []
                        for year in years:
                            for q in range(1, num_days + 1):
                                c_month = q * 3 - 2
                                week_start = c.monthdatescalendar(year, c_month)[1][0]
                                if (c.monthdatescalendar(year, c_month)[1][0]).day == 8:
                                    week_start = c.monthdatescalendar(year, c_month)[0][0]
                                quarter_dates.append(week_start)

                        for date in quarter_dates:
                            for w in range(1, num_weeks + 1):
                                from_date = date + timedelta(days=7*(w-1))
                                to_date = from_date + timedelta(days=6)
                                from_date_str = from_date.strftime('%Y-%m-%d')
                                to_date_str = to_date.strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' BETWEEN \'' + \
                                              from_date_str + '\' AND \'' + to_date_str + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                else:
                    if num_dict['D'] != 0:
                        # Q, D
                        # First n days of first n quarters of [years]
                        #print('IF-F3')
                        num_days = int(num_dict['Q'])
                        quarter_dates = []
                        for year in years:
                            for q in range(1, num_days + 1):
                                c_month = q * 3 - 2
                                date = datetime(year, c_month, 1)
                                quarter_dates.append(date)
                        num_days = int(num_dict['D'])
                        for date in quarter_dates:
                            from_date_str = date.strftime('%Y-%m-%d')
                            to_date_str = (date + timedelta(days=num_days-1)).strftime('%Y-%m-%d')
                            conditions += '(' + date_col + ' BETWEEN \'' + \
                                          from_date_str + '\' AND \'' + to_date_str + '\') OR '

                        conditions = conditions[:-4]
                        return conditions
                    else:
                        # Q
                        # First n quarters of [years]
                        #print('IF-F4')
                        start_q = 1
                        end_q = int(num_dict['Q'])

                        if end_q == start_q:
                            conditions += '(' + quarter_col + ' = \'' + str(end_q) + \
                                          '\') AND ('
                        else:
                            conditions += '(' + quarter_col + ' BETWEEN \'' + str(start_q) + '\' AND \'' + str(end_q) \
                                          + '\') AND ('

                        for year in years:
                            conditions += year_col + ' = \'' + str(year) + '\' OR '

                        conditions = conditions[:-4]
                        conditions += ')'
                        return conditions

        else:
            if num_dict['M']:
                if num_dict['W'] != 0:
                    if num_dict['D'] != 0:
                        # M, W, D
                        #print('Reached first n days of first n weeks of first n months of [years]. TO IMPLEMENT')
                        return 'NAN'
                    else:
                        # M, W
                        # TODO: Convert to week col
                        # First n weeks of first n months of [years]
                        #print('IF-F5')
                        num_days = int(num_dict['M'])
                        num_weeks = int(num_dict['W'])
                        quarter_dates = []
                        for year in years:
                            for m in range(1, num_days + 1):
                                c_month = m
                                week_start = c.monthdatescalendar(year, c_month)[1][0]
                                if (c.monthdatescalendar(year, c_month)[1][0]).day == 8:
                                    week_start = c.monthdatescalendar(year, c_month)[0][0]
                                quarter_dates.append(week_start)

                        for date in quarter_dates:
                            for w in range(1, num_weeks + 1):
                                from_date = date + timedelta(days=7 * (w - 1))
                                to_date = from_date + timedelta(days=6)
                                from_date_str = from_date.strftime('%Y-%m-%d')
                                to_date_str = to_date.strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' BETWEEN \'' + \
                                              from_date_str + '\' AND \'' + to_date_str + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                else:
                    if num_dict['D'] != 0:
                        # M, D
                        # First n days of first n months of [years]
                        #print('IF-F6')
                        num_months = int(num_dict['M'])
                        num_days = int(num_dict['D'])
                        month_dates = []
                        for year in years:
                            for m in range(1, num_months + 1):
                                date = datetime(year, m, 1)
                                month_dates.append(date)

                        for date in month_dates:
                            from_date_str = date.strftime('%Y-%m-%d')
                            to_date_str = (date + timedelta(days=num_days - 1)).strftime('%Y-%m-%d')
                            conditions += '(' + date_col + ' BETWEEN \'' + \
                                          from_date_str + '\' AND \'' + to_date_str + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                    else:
                        # M
                        # First n months of [years]
                        #print('IF-F7')
                        start_month = 1
                        end_month = int(num_dict['M'])
                        conditions = '(' + month_col + ' BETWEEN \'' + str(start_month) + '\' AND \'' + \
                                      str(end_month) + '\') AND ('

                        for year in years:
                            conditions += year_col + ' = \'' + str(year) + '\' OR '

                        conditions = conditions[:-4]
                        conditions += ')'
                        return conditions
            else:
                if num_dict['W'] != 0:
                    if num_dict['D'] != 0:
                        # W, D
                        #print('Reached first n days of first n weeks of [years]. TO IMPLEMENT')
                        return 'NAN'
                    else:
                        # W
                        # First n weeks of [years]
                        #print('IF-F8')
                        start_w = 1
                        end_w = int(num_dict['W'])

                        if start_w == end_w:
                            conditions += '(' + week_col + ' = \'' + str(start_w) + \
                                          '\') AND ('
                        else:
                            conditions += '(' + week_col + ' BETWEEN \'' + str(start_w) + '\' AND \'' + str(end_w) \
                                          + '\') AND ('

                        for year in years:
                            conditions += year_col + ' = \'' + str(year) + '\' OR '

                        conditions = conditions[:-4]
                        conditions += ')'
                        return conditions

                else:
                    if num_dict['D'] != 0:
                        # D
                        # First n days of [years]
                        #print('IF-F9')
                        num_days = int(num_dict['D'])
                        for year in years:
                            from_date = datetime(year, 1, 1)
                            to_date = from_date + timedelta(days=(num_days-1))
                            from_date_str = from_date.strftime('%Y-%m-%d')
                            to_date_str = to_date.strftime('%Y-%m-%d')
                            conditions += '(' + date_col + ' BETWEEN \'' + \
                                          from_date_str + '\' AND \'' + to_date_str + '\') OR '
                        conditions = conditions[:-4]
                        return conditions

    else:
        if ind_dict['Q']:
            if ind_dict['M']:
                if ind_dict['W'] != 0:
                    if ind_dict['D'] != 0:
                        # Q, M, W, D
                        #print('IF18')
                        # nth day of nth week of nth month of nth quarter of [years]
                        for year in years:
                            for quarter in ind_dict['Q']:
                                for ind_month in ind_dict['M']:
                                    q_num = int(quarter.split('Q')[1])
                                    month = (q_num * 3) - 2 + ind_month - 1

                                    week_start = c.monthdatescalendar(year, month)[int(ind_dict['W'])][0]
                                    if (c.monthdatescalendar(year, month)[1][0]).day == 8:
                                        week_start = c.monthdatescalendar(year, month)[int(ind_dict['W'])-1][0]
                                    c_date = week_start + timedelta(days=int(ind_dict['D'])-1)
                                    d_str = c_date.strftime('%Y-%m-%d')
                                    conditions += '(' + date_col + ' = \'' + d_str + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                    else:
                        # Q, M, W
                        #print('IF19')
                        # TODO: Convert to week col
                        # nth week of nth month of nth quarter of [years]
                        for year in years:
                            for quarter in ind_dict['Q']:
                                for ind_month in ind_dict['M']:
                                    q_num = int(quarter.split('Q')[1])
                                    month = (q_num * 3) - 2 + ind_month - 1
                                    week_start = c.monthdatescalendar(year, month)[int(ind_dict['W'])][0]
                                    if (c.monthdatescalendar(year, month)[1][0]).day == 8:
                                        week_start = c.monthdatescalendar(year, month)[int(ind_dict['W']) - 1][0]
                                    from_date = week_start.strftime('%Y-%m-%d')
                                    to_date = (week_start + timedelta(days=6)).strftime('%Y-%m-%d')
                                    conditions += '(' + date_col + ' BETWEEN \'' + from_date +\
                                                  '\' AND \'' + to_date + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                else:
                    if ind_dict['D'] != 0:
                        # Q, M, D
                        #print('IF20')
                        # nth day of nth month of nth quarter of [years]
                        for year in years:
                            for quarter in ind_dict['Q']:
                                for ind_month in ind_dict['M']:
                                    q_num = int(quarter.split('Q')[1])
                                    month = (q_num * 3) - 2 + ind_month - 1
                                    c_date = datetime(int(year), month, int(ind_dict['D']))
                                    d_str = c_date.strftime('%Y-%m-%d')
                                    conditions += '(' + date_col + ' = \'' + d_str + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                    else:
                        # Q, M
                        #print('IF23')
                        # nth month of quarter 1 and quarter 3 in [years]
                        conditions += '('
                        for quarter in ind_dict['Q']:
                            for ind_month in ind_dict['M']:
                                q_num = int(quarter.split('Q')[1])
                                month = (q_num * 3) - 2 + ind_month - 1
                                conditions += '(' + month_col + ' = \'' + str(month) + '\' OR '

                        conditions = conditions[:-4]
                        conditions += ') AND ('
                        for year in years:
                            conditions += year_col + ' = \'' + str(year) + '\' OR '

                        conditions = conditions[:-4]
                        conditions += ')'
                        return conditions
            else:
                if ind_dict['W'] != 0:
                    if ind_dict['D'] != 0:
                        # Q, W, D
                        # nth day of nth week of nth quarter in [years]
                        #print('IF24')
                        for year in years:
                            for quarter in ind_dict['Q']:
                                q_num = int(quarter.split('Q')[1])
                                month = (q_num * 3) - 2
                                week_start = c.monthdatescalendar(year, month)[1][0]
                                if week_start.day == 8:
                                    week_start = c.monthdatescalendar(year, month)[0][0]
                                week_start = week_start + timedelta(days=7*(int(ind_dict['W'])-1))
                                c_date = week_start + timedelta(days=int(ind_dict['D'])-1)
                                d_str = c_date.strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' = \'' + d_str + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                    else:
                        # Q, W
                        # nth week of nth quarter in [years]
                        # TODO: Convert to week col
                        #print('IF25')
                        for year in years:
                            for quarter in ind_dict['Q']:
                                q_num = int(quarter.split('Q')[1])
                                month = (q_num * 3) - 2
                                week_start = c.monthdatescalendar(year, month)[int(ind_dict['W'])][0]
                                if (c.monthdatescalendar(year, month)[1][0]).day == 8:
                                    week_start = c.monthdatescalendar(year, month)[int(ind_dict['W']) - 1][0]
                                from_date = week_start.strftime('%Y-%m-%d')
                                to_date = (week_start + timedelta(days=6)).strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' BETWEEN \'' + from_date \
                                              + '\' AND \'' + to_date + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                else:
                    if ind_dict['D'] != 0:
                        # Q, D
                        # nth day of nth quarter in [years]
                        #print('IF26')
                        for year in years:
                            for quarter in ind_dict['Q']:
                                q_num = int(quarter.split('Q')[1])
                                month = (q_num * 3) - 2
                                init_date = datetime(int(year), month, 1)
                                c_date = (init_date + timedelta(days=int(ind_dict['D'])-1)).strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' = \'' + c_date + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                    else:
                        # Q
                        #print('IF27')

                        if num_dict['M']:
                            # 1st n months of Q1 and Q3 of [years]
                            #print('IF-F10')
                            num_months = int(num_dict['M'])
                            quarter_dates = []

                            for q in ind_dict['Q']:
                                for m in range(1, num_months+1):
                                    q1 = int(q.split('Q')[1])
                                    months.append(q1 * 3 - 3 + m)

                            conditions += '('
                            for month in months:
                                conditions += month_col + ' = \'' + str(month) + '\' OR '

                            conditions = conditions[:-4]
                            conditions += ') AND ('

                            for year in years:
                                conditions += year_col + ' = \'' + str(year) + '\' OR '

                            conditions = conditions[:-4]
                            conditions += ')'
                            return conditions

                        if num_dict['W']:
                            # 1st n weeks of Q1 and Q3 of [years]
                            # TODO: Convert to week col
                            #print('IF-F11')
                            num_weeks = int(num_dict['W'])
                            quarter_dates = []
                            for year in years:
                                for q in ind_dict['Q']:
                                    q1 = int(q.split('Q')[1])
                                    c_month = q1 * 3 - 2
                                    week_start = c.monthdatescalendar(year, c_month)[1][0]
                                    if (c.monthdatescalendar(year, c_month)[1][0]).day == 8:
                                        week_start = c.monthdatescalendar(year, c_month)[0][0]
                                    quarter_dates.append(week_start)

                            for date in quarter_dates:
                                for w in range(1, num_weeks + 1):
                                    from_date = date + timedelta(days=7 * (w - 1))
                                    to_date = from_date + timedelta(days=6)
                                    from_date_str = from_date.strftime('%Y-%m-%d')
                                    to_date_str = to_date.strftime('%Y-%m-%d')
                                    conditions += '(' + date_col + ' BETWEEN \'' + \
                                                  from_date_str + '\' AND \'' + to_date_str + '\') OR '
                            conditions = conditions[:-4]
                            return conditions

                        if num_dict['D'] != 0:
                            # 1st n days of Q1 and Q3 of [years]
                            #print('IF-F12')
                            num_days = int(num_dict['D'])
                            quarter_dates = []
                            for year in years:
                                for q in ind_dict['Q']:
                                    q1 = int(q.split('Q')[1])
                                    c_month = q1 * 3 - 2
                                    date = datetime(year, c_month, 1)
                                    quarter_dates.append(date)

                            for date in quarter_dates:
                                from_date = date
                                to_date = date + timedelta(days=num_days-1)
                                from_date_str = from_date.strftime('%Y-%m-%d')
                                to_date_str = to_date.strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' BETWEEN \'' + \
                                              from_date_str + '\' AND \'' + to_date_str + '\') OR '

                            conditions = conditions[:-4]
                            return conditions

                        if num_dict['DPREV'] != 0:
                            # last n days of Q1 and Q3 of [years]
                            #print('IF-F13')
                            num_days = int(num_dict['DPREV'])
                            quarter_dates = []
                            for year in years:
                                for q in ind_dict['Q']:
                                    q1 = int(q.split('Q')[1])
                                    c_month = q1 * 3
                                    last_day = calendar.monthrange(year, c_month)[1]
                                    date = datetime(year, c_month, last_day)
                                    quarter_dates.append(date)

                            for date in quarter_dates:
                                to_date = date
                                from_date = date - timedelta(days=num_days-1)
                                from_date_str = from_date.strftime('%Y-%m-%d')
                                to_date_str = to_date.strftime('%Y-%m-%d')
                                if to_date_str == from_date_str:
                                    conditions += '(' + date_col + ' = \'' + to_date_str + '\') OR '
                                else:
                                    conditions += '(' + date_col + ' BETWEEN \'' + \
                                              from_date_str + '\' AND \'' + to_date_str + '\') OR '

                            conditions = conditions[:-4]
                            return conditions

                        # Reached when only quarter index is referenced and no months, weeks, days specified
                        conditions = '('
                        for quarter in ind_dict['Q']:
                            q_num = int(quarter.split('Q')[1])
                            conditions += quarter_col + ' = \'' + str(q_num) + '\' OR '
                        conditions = conditions[:-4]
                        conditions += ') AND ('

                        for year in years:
                            conditions += year_col + ' = \'' + str(year) + '\' OR '

                        conditions = conditions[:-4]
                        conditions += ')'

                        return conditions
        else:
            if ind_dict['M']:
                if ind_dict['W'] != 0:
                    if ind_dict['D'] != 0:
                        # M, W, D
                        # nth day of nth week of nth month of [years]
                        #print('IF29')
                        for year in years:
                            for ind_month in ind_dict['M']:
                                month = ind_month
                                week_start = c.monthdatescalendar(year, month)[int(ind_dict['W'])][0]
                                if (c.monthdatescalendar(year, month)[1][0]).day == 8:
                                    week_start = c.monthdatescalendar(year, month)[int(ind_dict['W']) - 1][0]
                                c_date = week_start + timedelta(days=int(ind_dict['D'])-1)
                                d_str = c_date.strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' = \'' + d_str + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                    else:
                        # M, W
                        # nth week of nth month of [years]
                        # TODO: Convert to week col
                        #print('IF30')
                        for year in years:
                            for ind_month in ind_dict['M']:
                                month = ind_month
                                week_start = c.monthdatescalendar(year, month)[int(ind_dict['W'])][0]
                                if (c.monthdatescalendar(year, month)[1][0]).day == 8:
                                    week_start = c.monthdatescalendar(year, month)[int(ind_dict['W']) - 1][0]
                                from_date = week_start.strftime('%Y-%m-%d')
                                to_date = (week_start + timedelta(days=6)).strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' BETWEEN \'' + from_date\
                                              + '\' AND \'' + to_date + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                else:
                    if ind_dict['D'] != 0:
                        # M, D
                        #print('IF31')
                        # Getting nth day of nth month from first n quarters from [years]
                        if num_dict['Q'] != 0:
                            #print('IF31-2')
                            q_num = int(num_dict['Q'])
                            for year in years:
                                for i in range(1, q_num + 1):
                                    for ind_month in ind_dict['M']:
                                        month_num = ind_month
                                        date = datetime(year, (i * 3) - 2, ind_dict['D']-1)
                                        date = date.replace(month=date.month + (month_num - 1))
                                        d_str = date.strftime('%Y-%m-%d')
                                        conditions += '(' + date_col + ' = \'' + d_str + '\') OR '
                            conditions = conditions[:-4]
                            return conditions

                        # nth day of nth month of [years]
                        for year in years:
                            for ind_month in ind_dict['M']:
                                month = ind_month
                                c_date = datetime(int(year), month, int(ind_dict['D']))
                                d_str = c_date.strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' = \'' + d_str + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                    else:
                        # M
                        #print('IF32')
                        # Getting nth month of past x quarters of [years]
                        if num_dict['QPREV'] != 0:
                            dates = []
                            if len(years) == 1 and years[0] == datetime.now().year:
                                # print('IF34')
                                # If referring to last n quarters from now
                                current_date = datetime.now()
                                curr_quarter = (current_date.month - 1) // 3 + 1
                                q_first_day = datetime(current_date.year, 3 * curr_quarter - 2, 1)
                                prev_month = q_first_day - timedelta(days=1)
                                prev_quarter = (prev_month.month - 1) // 3 + 1
                                prev_q_day = datetime(prev_month.year, 3 * prev_quarter - 2, 1)
                                num_days = int(num_dict['QPREV'])
                                dates.append(prev_q_day)
                                for i in range(num_days - 1):
                                    prev_q_day = prev_q_day - timedelta(days=1)
                                    curr_quarter = (prev_q_day.month - 1) // 3 + 1
                                    prev_q_day = datetime(prev_q_day.year, 3 * curr_quarter - 2, 1)
                                    dates.append(prev_q_day)
                            else:
                                # If referring to last n quarters of some specified years
                                if datetime.now().year in years:
                                    years.remove(datetime.now().year)
                                for year in years:
                                    last_quarter_begin = datetime(year, 10, 1)
                                    num_days = int(num_dict['QPREV'])
                                    dates.append(last_quarter_begin)
                                    for i in range(num_days - 1):
                                        last_quarter_begin = last_quarter_begin - timedelta(days=1)
                                        curr_quarter = (last_quarter_begin.month - 1) // 3 + 1
                                        last_quarter_begin = datetime(last_quarter_begin.year, 3 * curr_quarter - 2, 1)
                                        dates.append(last_quarter_begin)

                            for date in dates:
                                for ind_month in ind_dict['M']:
                                    month = date.month+(ind_month-1)
                                    year = date.year

                                    conditions += '(' + month_col + ' = \'' + str(month) + '\' AND ' + \
                                                  year_col + ' = \'' + str(year) + '\') OR '
                            
                            conditions = conditions[:-4]
                            return conditions

                        # Getting nth month from first n quarters from [years]
                        if num_dict['Q'] != 0:
                            #print('IF34')
                            q_num = int(num_dict['Q'])

                            conditions = '('
                            for i in range(1, q_num+1):
                                for ind_month in ind_dict['M']:
                                    month = (i*3)-2 + ind_month - 1
                                    conditions += month_col + ' = \'' + str(month) + '\' OR '

                            conditions = conditions[:-4]
                            conditions += ') AND ('

                            for year in years:
                                conditions += year_col + ' = \'' + str(year) + '\' OR '
                            conditions = conditions[:-4]
                            conditions += ')'
                            return conditions

                        # What is the revenue for 1st n weeks of nth month in [years]
                        # TODO: Convert to week col
                        if num_dict['W']:
                            # print('IF-F13')
                            num_weeks = int(num_dict['W'])
                            quarter_dates = []
                            # print('WEEKS: ',num_weeks)
                            # print('MONTH: ',ind_dict['M'])
                            # print('YEARS: ', years)
                            for year in years:
                                for m in ind_dict['M']:
                                    c_month = m
                                    week_start = c.monthdatescalendar(year, c_month)[1][0]
                                    if (c.monthdatescalendar(year, c_month)[1][0]).day == 8:
                                        week_start = c.monthdatescalendar(year, c_month)[0][0]
                                    quarter_dates.append(week_start)

                            for date in quarter_dates:
                                for w in range(1, num_weeks + 1):
                                    from_date = date + timedelta(days=7 * (w - 1))
                                    to_date = from_date + timedelta(days=6)
                                    from_date_str = from_date.strftime('%Y-%m-%d')
                                    to_date_str = to_date.strftime('%Y-%m-%d')
                                    conditions += '(' + date_col + ' BETWEEN \'' + \
                                                  from_date_str + '\' AND \'' + to_date_str + '\') OR '
                            conditions = conditions[:-4]
                            return conditions

                        # What is the revenue for 1st 5 days of 1st month and 2nd month in [years]
                        if num_dict['D']:
                            #print('IF-F14')
                            num_days = int(num_dict['M'])
                            num_days = int(num_dict['D'])
                            quarter_dates = []
                            for year in years:
                                for m in ind_dict['M']:
                                    date = datetime(year, m, 1)
                                    quarter_dates.append(date)

                            for date in quarter_dates:
                                from_date = date
                                to_date = from_date + timedelta(days=(num_days - 1))
                                from_date_str = from_date.strftime('%Y-%m-%d')
                                to_date_str = to_date.strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' BETWEEN \'' + \
                                              from_date_str + '\' AND \'' + to_date_str + '\') OR '
                            conditions = conditions[:-4]
                            return conditions

                        if num_dict['DPREV'] != 0:
                            # last n days of Q1 and Q3 of [years]
                            #print('IF-F14')
                            num_days = int(num_dict['DPREV'])
                            quarter_dates = []
                            for year in years:
                                for m in ind_dict['M']:
                                    c_month = int(m)
                                    last_day = calendar.monthrange(year, c_month)[1]
                                    date = datetime(year, c_month, last_day)
                                    quarter_dates.append(date)

                            for date in quarter_dates:
                                to_date = date
                                from_date = date - timedelta(days=num_days-1)
                                from_date_str = from_date.strftime('%Y-%m-%d')
                                to_date_str = to_date.strftime('%Y-%m-%d')
                                if to_date_str == from_date_str:
                                    conditions += '(' + date_col + ' = \'' + to_date_str + '\') OR '
                                else:
                                    conditions += '(' + date_col + ' BETWEEN \'' + \
                                              from_date_str + '\' AND \'' + to_date_str + '\') OR '

                            conditions = conditions[:-4]
                            return conditions

                        # Getting nth month of [years]
                        #print('IF M')
                        conditions = '('
                        for ind_month in ind_dict['M']:
                            month = ind_month
                            conditions += month_col + ' = \'' + str(month) + '\' OR '

                        conditions = conditions[:-4]
                        conditions += ') AND ('
                        if not years:
                            conditions = conditions[:-6]
                            return conditions
                        for year in years:
                            conditions += year_col + ' = \'' + str(year) + '\' OR '

                        conditions = conditions[:-4]
                        conditions += ')'
                        return conditions
            else:
                if ind_dict['W'] != 0:
                    if ind_dict['D'] != 0:
                        # W, D
                        # nth day of nth week of [years]
                        #print('IF36')
                        month = 1
                        for year in years:
                            week_start = c.monthdatescalendar(year, month)[1][0]
                            if week_start.day == 8:
                                week_start = c.monthdatescalendar(year, month)[0][0]
                            week_start = week_start + timedelta(days=7 * (int(ind_dict['W'])-1))
                            c_date = week_start + timedelta(days=int(ind_dict['D'])-1)
                            d_str = c_date.strftime('%Y-%m-%d')
                            conditions += '(' + date_col + ' = \'' + d_str + '\') OR '
                        conditions = conditions[:-4]
                        return conditions
                    else:
                        # W
                        #print('IF37')
                        # Getting nth week of past x months
                        # TODO: Convert week col
                        if num_dict['MPREV'] != 0:
                            #print('IF38')
                            months = []
                            if len(years) == 1 and years[0] == datetime.now().year:
                                now = datetime.now()
                                last_month = datetime(now.year, now.month, 1) - timedelta(days=1)
                                last_month.replace(day=1)
                                num_days = int(num_dict['MPREV'])
                                months = [last_month]
                                c_month = last_month
                                for i in range(num_days - 1):
                                    c_month = datetime(c_month.year, c_month.month, 1) - timedelta(days=1)
                                    c_month = c_month.replace(day=1)
                                    months.append(c_month)
                            else:
                                if datetime.now().year in years:
                                    years.remove(datetime.now().year)
                                for year in years:
                                    l_month = datetime(year, 12, 1)
                                    num_days = int(num_dict['MPREV'])
                                    months = [l_month]
                                    c_month = l_month
                                    for i in range(num_days - 1):
                                        c_month = datetime(c_month.year, c_month.month, 1) - timedelta(days=1)
                                        c_month = c_month.replace(day=1)
                                        months.append(c_month)
                            #print(months)
                            for month in months:
                                week_start = c.monthdatescalendar(month.year, month.month)[1][0]
                                if week_start.day == 8:
                                    week_start = c.monthdatescalendar(month.year, month.month)[0][0]
                                from_date = (week_start + timedelta(days=7 * (int(ind_dict['W']) - 1)))
                                from_date_str = from_date.strftime('%Y-%m-%d')
                                to_date = (from_date + timedelta(days=6)).strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' BETWEEN \'' + from_date_str \
                                              + '\' AND \'' + to_date + '\') OR '
                            conditions = conditions[:-4]
                            return conditions

                        # Getting nth week of past x quarters
                        # TODO: Convert week col
                        if num_dict['QPREV'] != 0:
                            #print('IF39')
                            dates = []
                            if len(years) == 1 and years[0] == datetime.now().year:
                                # If referring to last n quarters from now
                                current_date = datetime.now()
                                curr_quarter = (current_date.month - 1) // 3 + 1
                                q_first_day = datetime(current_date.year, 3 * curr_quarter - 2, 1)
                                prev_month = q_first_day - timedelta(days=1)
                                prev_quarter = (prev_month.month - 1) // 3 + 1
                                prev_q_day = datetime(prev_month.year, 3 * prev_quarter - 2, 1)
                                num_days = int(num_dict['QPREV'])
                                dates.append(prev_q_day)
                                for i in range(num_days - 1):
                                    prev_q_day = prev_q_day - timedelta(days=1)
                                    curr_quarter = (prev_q_day.month - 1) // 3 + 1
                                    prev_q_day = datetime(prev_q_day.year, 3 * curr_quarter - 2, 1)
                                    dates.append(prev_q_day)
                            else:
                                # If referring to last n quarters of some specified years
                                if datetime.now().year in years:
                                    years.remove(datetime.now().year)
                                for year in years:
                                    last_quarter_begin = datetime(year, 10, 1)
                                    num_days = int(num_dict['QPREV'])
                                    dates.append(last_quarter_begin)
                                    for i in range(num_days - 1):
                                        last_quarter_begin = last_quarter_begin - timedelta(days=1)
                                        curr_quarter = (last_quarter_begin.month - 1) // 3 + 1
                                        last_quarter_begin = datetime(last_quarter_begin.year, 3 * curr_quarter - 2,
                                                                      1)
                                        dates.append(last_quarter_begin)
                            #print(dates)
                            for date in dates:
                                week_start = c.monthdatescalendar(date.year, date.month)[1][0]
                                if week_start.day == 8:
                                    week_start = c.monthdatescalendar(date.year, date.month)[0][0]
                                from_date = (week_start + timedelta(days=7 * (int(ind_dict['W']) - 1)))
                                from_date_str = from_date.strftime('%Y-%m-%d')
                                to_date = (from_date + timedelta(days=6)).strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' BETWEEN \'' + from_date_str +\
                                              '\' AND \'' + to_date + '\') OR '
                            conditions = conditions[:-4]
                            return conditions

                        # Getting nth week of [years]
                        #print('IF W')

                        conditions = '(' + week_col + ' = \'' + str(ind_dict['W']) + '\') AND ('

                        for year in years:
                            conditions += year_col + ' = \'' + str(year) + '\' OR '
                        conditions = conditions[:-4]
                        conditions += ')'
                        return conditions
                else:
                    if ind_dict['D'] != 0:
                        # D
                        #print('IF41')
                        # Getting nth day of past x weeks
                        if num_dict['WPREV'] != 0:
                            #print('IF42')
                            num_weeks = int(num_dict['WPREV'])
                            last_week = datetime.now() - timedelta(days=datetime.now().weekday()+7)
                            weeks = [last_week]
                            c_week = last_week
                            for i in range(num_weeks-1):
                                c_week = c_week - timedelta(days=7)
                                weeks.append(c_week)
                            for week in weeks:
                                c_date = (week + timedelta(days=int(ind_dict['D']) - 1))
                                d_str = c_date.strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' = \'' + d_str + '\') OR '
                            conditions = conditions[:-4]
                            return conditions

                        # Getting nth day of past x months
                        if num_dict['MPREV'] != 0:
                            #print('IF43')
                            months = []
                            if len(years) == 1 and years[0] == datetime.now().year:
                                now = datetime.now()
                                last_month = datetime(now.year, now.month, 1) - timedelta(days=1)
                                last_month.replace(day=1)
                                num_days = int(num_dict['MPREV'])
                                months = [last_month]
                                c_month = last_month
                                for i in range(num_days - 1):
                                    c_month = datetime(c_month.year, c_month.month, 1) - timedelta(days=1)
                                    c_month = c_month.replace(day=1)
                                    months.append(c_month)
                            else:
                                if datetime.now().year in years:
                                    years.remove(datetime.now().year)
                                for year in years:
                                    l_month = datetime(year, 12, 1)
                                    num_days = int(num_dict['MPREV'])
                                    months = [l_month]
                                    c_month = l_month
                                    for i in range(num_days - 1):
                                        c_month = datetime(c_month.year, c_month.month, 1) - timedelta(days=1)
                                        c_month = c_month.replace(day=1)
                                        months.append(c_month)
                            #print(months)
                            for month in months:
                                c_date = month.replace(day=int(ind_dict['D']))
                                d_str = c_date.strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' = \'' + d_str + '\') OR '
                            conditions = conditions[:-4]
                            return conditions

                        # Getting nth day of past x quarters
                        if num_dict['QPREV'] != 0:
                            #print('IF44')
                            dates = []
                            if len(years) == 1 and years[0] == datetime.now().year:
                                # If referring to last n quarters from now
                                current_date = datetime.now()
                                curr_quarter = (current_date.month - 1) // 3 + 1
                                q_first_day = datetime(current_date.year, 3 * curr_quarter - 2, 1)
                                prev_month = q_first_day - timedelta(days=1)
                                prev_quarter = (prev_month.month - 1) // 3 + 1
                                prev_q_day = datetime(prev_month.year, 3 * prev_quarter - 2, 1)
                                num_days = int(num_dict['QPREV'])
                                dates.append(prev_q_day)
                                for i in range(num_days - 1):
                                    prev_q_day = prev_q_day - timedelta(days=1)
                                    curr_quarter = (prev_q_day.month - 1) // 3 + 1
                                    prev_q_day = datetime(prev_q_day.year, 3 * curr_quarter - 2, 1)
                                    dates.append(prev_q_day)
                            else:
                                # If referring to last n quarters of some specified years
                                if datetime.now().year in years:
                                    years.remove(datetime.now().year)
                                for year in years:
                                    last_quarter_begin = datetime(year, 10, 1)
                                    num_days = int(num_dict['QPREV'])
                                    dates.append(last_quarter_begin)
                                    for i in range(num_days - 1):
                                        last_quarter_begin = last_quarter_begin - timedelta(days=1)
                                        curr_quarter = (last_quarter_begin.month - 1) // 3 + 1
                                        last_quarter_begin = datetime(last_quarter_begin.year, 3 * curr_quarter - 2,
                                                                      1)
                                        dates.append(last_quarter_begin)
                            #print(dates)
                            for date in dates:
                                c_date = date.replace(day=int(ind_dict['D']))
                                d_str = c_date.strftime('%Y-%m-%d')
                                conditions += '(' + date_col + ' = \'' + d_str + '\') OR '
                            conditions = conditions[:-4]
                            return conditions

                        # nth day of [years]
                        for year in years:
                            f_date = datetime(year, 1, 1)
                            c_date = (f_date + timedelta(days=int(ind_dict['D'])-1))
                            d_str = c_date.strftime('%Y-%m-%d')
                            conditions += '(' + date_col + ' = \'' + d_str + '\') OR '
                        conditions = conditions[:-4]
                        return conditions

    if num_dict['YPREV'] != 0:
        to_year = datetime.now().year
        from_year = to_year - int(num_dict['YPREV'])
        conditions += year_col + ' BETWEEN \'' + str(from_year) + '\' AND \'' + str(to_year) + '\''
        return conditions

    return 'NAN'

def replace_keywords(question):
    mod_question = question
    while 'between' in mod_question:
        if 'between' in mod_question.lower() and 'and' in mod_question.lower():
            mod_question = re.sub("(?i)between", "from", question, 1)
            mod_question = re.sub("(?i)and", "to", mod_question, 1)
        elif 'between' in mod_question.lower():
            mod_question = re.sub("(?i)between", "from", question, 1)

    return mod_question


def standardize_quarter(question):
    quarter_at_end = True
    quarter_w_something_after = True
    while quarter_at_end or quarter_w_something_after:
        quarter_at_end = re.search("(q\\s?[1-4]$)|(quarter\\s?[1-4]$)", question, re.IGNORECASE)
        quarter_w_something_after = re.search("(q\\s?[1-4][\\s.!?,])|(quarter\\s?[1-4][\\s.!?,])", question, re.IGNORECASE)
        if quarter_at_end:
            ref_quarter = quarter_at_end.group()
            if '1' in ref_quarter:
                question = question.replace(ref_quarter, '1st quarter')
            elif '2' in ref_quarter:
                question = question.replace(ref_quarter, '2nd quarter')
            elif '3' in ref_quarter:
                question = question.replace(ref_quarter, '3rd quarter')
            elif '4' in ref_quarter:
                question = question.replace(ref_quarter, '4th quarter')

        elif quarter_w_something_after:
            ref_quarter = quarter_w_something_after.group()
            if '1' in ref_quarter:
                question = question.replace(ref_quarter, '1st quarter' + ref_quarter[-1])
            elif '2' in ref_quarter:
                question = question.replace(ref_quarter, '2nd quarter' + ref_quarter[-1])
            elif '3' in ref_quarter:
                question = question.replace(ref_quarter, '3rd quarter' + ref_quarter[-1])
            elif '4' in ref_quarter:
                question = question.replace(ref_quarter, '4th quarter' + ref_quarter[-1])

    return question


def get_duckling_result(question, input_columns, input_types):
    conditions = ''
    mod_ques = question.replace('the ', '')
    c_cond = ''
    duck_date = d.parse_time(mod_ques)
    if not duck_date:
        return 'NAN'
    result_dict = duck_date[0]['value']
    for result in duck_date:
        if type(result['value']['value']) is dict:
            result_dict = result['value']
            break
    date_range = False
    if type(result_dict['value']) is dict:
        date_range = True

    if 'date' in input_types:
        date_col = input_columns[input_types.index('date')]

    if 'week' in input_types:
        week_col = input_columns[input_types.index('week')]

    if 'month' in input_types:
        month_col = input_columns[input_types.index('month')]

    if 'quarter' in input_types:
        quarter_col = input_columns[input_types.index('quarter')]

    if 'year' in input_types:
        year_col = input_columns[input_types.index('year')]

    if not date_range:
        grain = result_dict['grain']
        date_val = str(result_dict['value']).split('T')[0]
        date_val_split = date_val.split('-')
        if date_val_split[0].isdigit() and len(date_val_split[0]) == 4:
            if int(date_val_split[0]) > datetime.now().year:
                date_val_split[0] = str(datetime.now().year)
        if grain == 'month':
            c_cond += month_col + ' = \'' + date_val_split[1] + '\''
            c_cond += ' AND ' + year_col + ' = \'' + date_val_split[0] + '\''
            conditions += c_cond
        elif grain == 'week':
            c_date = datetime.strptime(str(date_val), '%Y-%m-%d')
            week_num = ((c_date - datetime(c_date.year, 1, 1)).days // 7) + 1
            year = c_date.year
            c_cond += week_col + ' = \'' + str(week_num) + '\' AND ' + year_col + ' = \'' + str(year) + '\''
            conditions += c_cond
        elif grain == 'day':
            c_cond += date_col + ' = \'' + date_val + '\''
            conditions += c_cond
        elif grain == 'year':
            c_cond += year_col + ' = \'' + date_val_split[0] + '\''
            conditions += c_cond
        elif grain == 'quarter':
            q_num = (int(date_val_split[1]) - 1) // 3 + 1
            year = int(date_val_split[0])
            c_cond += quarter_col + ' = \'' + str(q_num) + '\' AND ' + year_col + ' = \'' + str(year)
            conditions += c_cond
        else:
            return 'NAN'
    else:
        # Handle date range
        to_date = result_dict['value']['to']
        from_date = result_dict['value']['from']
        if to_date is None:
            # Case for 'after DATE'
            to_date = datetime.strftime(datetime.now(), '%Y-%m-%d')
            to_date = to_date.split('T')[0]
            year2 = to_date.split('-')[0]
            to_date_dt = datetime.strptime(str(to_date), '%Y-%m-%d') - timedelta(days=1)
            to_date_str = datetime.strftime(to_date_dt, '%Y-%m-%d')
            from_date = from_date.split('T')[0]
            year1 = from_date.split('-')[0]
            month = from_date.split('-')[1]
            c_year = datetime.now().year
            if int(str(year1)) > c_year and year1 not in mod_ques:
                year1 = str(c_year)
            if int(str(year2)) > c_year and year2 not in mod_ques:
                year2 = str(c_year)
            if 'date' in input_types:
                c_cond += date_col + ' > \'' + str(from_date) + '\''
            elif 'month' in input_types and 'year' in input_types:
                if int(month) != 12:
                    c_cond += '(' + month_col + ' > \'' + month + '\' AND ' + year_col + ' = \'' + year1 + \
                              '\') OR (' + year_col + ' > \'' + year1 + '\')'
                else:
                    c_cond += '(' + year_col + ' > \'' + year1 + '\')'
            elif 'month' not in input_types and 'year' in input_types:
                c_cond += year_col + ' > \'' + year1 + '\''
            conditions += c_cond
        elif from_date is None:
            # Case for 'before DATE'
            to_date = to_date.split('T')[0]
            year2 = to_date.split('-')[0]
            month = to_date.split('-')[1]
            c_year = datetime.now().year
            if int(str(year2)) > c_year and year2 not in mod_ques:
                year2 = str(c_year)
            if 'date' in input_types:
                c_cond += date_col + ' < \'' + str(to_date) + '\''
            elif 'month' in input_types and 'year' in input_types:
                if int(month) != 1:
                    c_cond += '(' + month_col + ' < \'' + month + '\' AND ' + year_col + ' = \'' + year2 + \
                          '\') OR (' + year_col + ' < \'' + year2 + '\')'
                else:
                    c_cond += '(' + year_col + ' < \'' + year2 + '\')'
            elif 'month' not in input_types and 'year' in input_types:
                c_cond += year_col + ' < \'' + year2 + '\''
            conditions += c_cond
        else:
            from_date = from_date.split('T')[0]
            to_date = to_date.split('T')[0]
            to_date_dt = datetime.strptime(str(to_date), '%Y-%m-%d') - timedelta(days=1)
            to_date_str = datetime.strftime(to_date_dt, '%Y-%m-%d')
            year1 = from_date.split('-')[0]
            year2 = to_date_str.split('-')[0]
            month1 = from_date.split('-')[1]
            month2 = to_date_str.split('-')[1]
            c_year = datetime.now().year
            if int(str(year1)) > c_year and year1 not in mod_ques:
                year1 = str(c_year)
            if int(str(year2)) > c_year and year2 not in mod_ques:
                year2 = str(c_year)
            if 'date' in input_types:
                c_cond += date_col + ' BETWEEN \'' + str(from_date) + '\' AND \'' + to_date_str + '\''
            elif 'month' in input_types and 'year' in input_types:
                if year1 == year2:
                    c_cond += month_col + ' >= \'' + month1 + '\' AND ' + month_col + ' <= \'' + month2 + \
                              '\' AND ' + year_col + ' = \'' + year1 + '\')'
                elif (int(year2) - int(year1)) == 1:
                    c_cond += '(' + month_col + ' >= \'' + month1 + '\' AND ' + year_col + ' = \'' + year1 + \
                              '\') OR (' + month_col + ' <= \'' + month2 + '\' AND ' + year_col + ' = \'' + year2 + '\')'
                else:
                    c_cond += '(' + month_col + ' >= \'' + month1 + '\' AND ' + year_col + ' = \'' + year1 + \
                              '\') OR (' + month_col + ' <= \'' + month2 + '\' AND ' + year_col + ' = \'' + year2 + '\') ' \
                              'OR (' + year_col + ' BETWEEN \'' + str(int(year1)+1) + '\' AND \'' + str(int(year2)-1) + '\')'
            elif 'month' not in input_types and 'year' in input_types:
                if year1 == year2:
                    c_cond += year_col + ' = \'' + year2 + '\''
                else:
                    c_cond += year_col + ' BETWEEN \'' + year1 + '\' AND \'' + year2 + '\''
            conditions += c_cond

    if conditions == '':
        conditions = 'NAN'
        return conditions
    if 'since' in mod_ques.lower() or 'after' in mod_ques.lower() \
        or 'before' in mod_ques.lower() or 'until' in mod_ques.lower():
        splt_conds = conditions.split(' ')
        if len(splt_conds) == 3:
            if splt_conds[1] == '=':
                if 'since' in mod_ques.lower() or 'after' in mod_ques.lower():
                    splt_conds[1] = '>'
                    conditions = ' '.join(splt_conds)
                elif 'before' in mod_ques.lower() or 'until' in mod_ques.lower():
                    splt_conds[1] = '<'
                    conditions = ' '.join(splt_conds)
    return conditions

def clean_future_dates(sutime_value):
    cur_year = str(datetime.now().year)
    prev_year = str(datetime.now().year-1)
    for value in sutime_value:
        #print(value['text'])
        year = re.search('[1-3][0-9]{3}', value['text'])
        if year:
            return sutime_value

    for i in range(len(sutime_value)):
        value = sutime_value[i]
        months = [x.lower() for x in list(calendar.month_name)]
        if 'timex-value' in value:
            if 'Q' in value['timex-value'] and len(value['timex-value']) == 7 and cur_year == value['timex-value'][:4]:
                # Current year and a quarter is being referenced in the result
                cur_q = ((datetime.now().month - 1) // 3) + 1
                response_q = value['timex-value'][-1]
                # If future date is referenced then replace current year with last year
                if cur_q < int(response_q):
                    sutime_value[i]['timex-value'] = sutime_value[i]['timex-value'].replace(cur_year, prev_year)
                    sutime_value[i]['value'] = sutime_value[i]['timex-value']

            elif len(value['timex-value']) == 7 and cur_year == value['timex-value'][:4] \
                    and value['text'].lower() in months:
                dash_split = value['timex-value'].split('-')
                #print('IF1')
                if len(dash_split) == 2 and len(dash_split[0]) == 4 and len(dash_split[1]) == 2:
                    #print('IF2')
                    # Current year and a month is being referenced in the result
                    curr_m = datetime.now().month
                    if dash_split[0] == cur_year and curr_m < int(dash_split[1]):
                        #print('IF3')
                        sutime_value[i]['timex-value'] = sutime_value[i]['timex-value'].replace(cur_year, prev_year)
                        sutime_value[i]['value'] = sutime_value[i]['timex-value']
                        sutime_value[i]['text'] += ' ' + prev_year
                    elif dash_split[0] == cur_year:
                        #print('IF4')
                        sutime_value[i]['text'] += ' ' + cur_year

    return sutime_value

def date_condition(question, input_columns, input_types, remove_tokens=None):
    if remove_tokens is not None:
        for token in remove_tokens:
            token = token.strip()
            question = question.replace(token + ' ', '')
            question = question.replace(' ' + token, '')

    # Cleaning natural language question (Replace (between, and) with (from, to). Replace fiscal with ''
    if 'between' in question.lower():
        question = replace_keywords(question)

    if 'fiscal' in question.lower():
        question = re.sub("(?i)fiscal\s", "", question)
        question = re.sub("(?i)\sfiscal", "", question)

    # Replace q1, Quarter 2 with 1st Quarter, 2nd Quarter
    question = standardize_quarter(question)

    sutime_value = sutime.parse(question)
    for i in range(len(sutime_value)-1):
        c_end = sutime_value[i]['end']
        nxt_begin = sutime_value[i+1]['start']
        if 'for' in question[c_end:nxt_begin] and (nxt_begin - c_end) == 5:
            question = question[:c_end] + ' of ' + question[nxt_begin:]
            break
    sutime_value = sutime.parse(question)
    conditions = []
    first = True

    # Replacing problematic the's
    if 'the' in question:
        for value in sutime_value:
            if (value['value'] == {} or 'UNKNOWN' in value['value'] or 'REF' in value['value']) \
                    and 'the' in value['text']:
                orig_text = value['text']
                new_text = orig_text.replace('the ', '')
                question = question.replace(orig_text, new_text)
                sutime_value = sutime.parse(question)
                break

    if not sutime_value:
        #print(question, ': DUCKLING')
        return get_duckling_result(question, input_columns, input_types)

    # Handle 'since last year', 'since last month of last year', etc...
    if 'since' in question.lower() or 'after' in question.lower() \
            or 'before' in question.lower() or 'until' in question.lower():
        #print(question, ': DUCKLING')
        return get_duckling_result(question, input_columns, input_types)

    # If contains quarter range then send to duckling
    if len(sutime_value) == 1 and type(sutime_value[0]['value']) is dict and sutime_value[0]['value'] != {}:
        if 'quarter' in sutime_value[0]['text']:
            #print(question, ': DUCKLING')
            return get_duckling_result(question, input_columns, input_types)

    # Check for future dates, replace with past date
    sutime_value = clean_future_dates(sutime_value)
    month_subset = False
    # If current year not mentioned in text returned by sutime, replace year with XXXX
    for value in sutime_value:
        if type(value['value']) is dict:
            continue
        years = re.findall('(\\d{4})', value['value'])
        txt_response = value['text']
        plural_months = ['januarys','februarys','marchs','aprils','mays','junes','julys','augusts','septembers','octobers','novembers','decembers']
        if not month_subset:
            month_subset = any([True for mon in plural_months if mon in txt_response.lower()])

        if str(datetime.now().year) in years and str(datetime.now().year) not in txt_response:
            value['value'] = value['value'].replace(str(datetime.now().year), 'XXXX')
            if 'timex-value' in value:
                value['timex-value'] = value['timex-value'].replace(str(datetime.now().year), 'XXXX')
        if str(datetime.now().year+1) in years and str(datetime.now().year+1) not in txt_response:
            value['value'] = value['value'].replace(str(datetime.now().year+1), 'XXXX')
            if 'timex-value' in value:
                value['timex-value'] = value['timex-value'].replace(str(datetime.now().year+1), 'XXXX')

    # Converting YYYY INTERSECT (XXXX-XX, XXXX-XX) into a range
    if len(sutime_value) == 1:
        if 'INTERSECT' in sutime_value[0]['value']:
            space_split = sutime_value[0]['value'].split(' ')
            if len(space_split[0]) == 4 and space_split[0].isdigit() and \
                    len(space_split) == 3 and '(' in space_split[2] and ')' in space_split[2]:
                comma_split = space_split[2].replace('(', '').replace(')', '').split(',')
                dash_split_begin = comma_split[0].split('-')
                dash_split_end = comma_split[1].split('-')

                dash_split_begin[0] = dash_split_begin[0].replace('XXXX', space_split[0])
                dash_split_end[0] = dash_split_end[0].replace('XXXX', space_split[0])
                for i in range(len(dash_split_begin)):
                    dash_split_begin[i] = dash_split_begin[i].zfill(2)
                for i in range(len(dash_split_end)):
                    dash_split_end[i] = dash_split_end[i].zfill(2)
                begin = '-'.join(dash_split_begin)
                begin = begin.strip('X')
                begin = begin.strip('-')
                end = '-'.join(dash_split_end)
                end = end.strip('X')
                end = end.strip('-')
                sutime_value[0]['value'] = {'end': end, 'begin': begin}

    # Check if day of week is being asked by user
    flag_dayofweek = False
    for value in sutime_value:
        if type(value['value']) != dict:
            find_dayofweek_ref = re.search("(([\\d]{4})|[X]{4})-W[X]{2}-[\\d]", value['value'])
            if find_dayofweek_ref and len(value['value']) == 10:
                flag_dayofweek = True
            elif find_dayofweek_ref:
                if 'OFFSET' in value['value'] and 'INTERSECT' in value['value']:
                    find_ref_years = re.search('P[\\d]Y', value['value'])
                    if find_ref_years:
                        num_years = find_ref_years.group(0)
                        value['value'] = 'PREV ' + num_years + ' INTERSECT ' + find_dayofweek_ref.group(0)
                        flag_dayofweek = True

    #print('Before processing: ', sutime_value)
    #print('Flag: ', flag_dayofweek)

    #print('Output after cleaning sutime output: ', sutime_value)

    combined_intersect = ''
    combined_values = ''
    contains_range = False
    len_1_contains_duration = False

    week_subset = False
    
    # Parsing each value returned by sutime and cleaning

    # Parsing each value returned by sutime and cleaning
    if len(sutime_value) > 1:
        for value in sutime_value:
            if value['value'] == {}:
                #print(question, ': DUCKLING')
                return get_duckling_result(question, input_columns, input_types)
            if type(value['value']) is not dict:
                # Parsing and checking whether P3M, P6M refers to month or quarters
                is_quarter = re.search("(P\\d{1,2}M([^-]|$))", value['value']) and 'quarter' in value['text'].lower()
                if is_quarter:
                    p_x_m = re.search("(P\\d{1,2}M([^-]|$))", value['value']).group(1).strip()
                    month = int(re.search(r'\d+', p_x_m).group())
                    if month % 3 == 0:
                        quarter = int(month/3)
                        val = 'P' + str(quarter) + 'Q'
                        value['value'] = value['value'].replace(p_x_m, val)

                if 'timex-value' in value:
                    if value['timex-value'] == value['value']:
                        dash_splt = value['timex-value'].split('-')
                        if len(dash_splt) == 2 and len(dash_splt[0]) == 4 and (dash_splt[0]).isdigit() \
                            and len(dash_splt[1]) == 2 and (dash_splt[1]).isdigit():
                            txt_response = value['text']
                            month = int(dash_splt[1])
                            year = dash_splt[0]
                            month_pres = calendar.month_name[month].lower() in txt_response.lower()
                            quarter_pres = txt_response.lower().find('quarter')
                            if not month_pres and quarter_pres != -1:
                                q_num = txt_response[quarter_pres-4]
                                if q_num.isdigit():
                                    new_val = 'P1M-#' + str(month) + ' INTERSECT ' + year + '-' + 'Q' + q_num
                                    del value['timex-value']
                                    value['value'] = new_val
                        if len(dash_splt) > 1:
                            if dash_splt[1] == 'WE' or dash_splt[1] == 'WD':
                                week_subset = True

            is_duration = type(value['value']) is dict and value['value'] != {}
            if is_duration:
                if 'begin' not in value['value'] or 'end' not in value['value']:
                    #print(question, ': DUCKLING')
                    return get_duckling_result(question, input_columns, input_types)
            # contains_duration checks for duration of form { 'end': '', 'begin': '' }
            contains_duration = type(value['value']) is dict and value['value'] != {} \
                                and len(value['value']['end']) > 0 and len(value['value']['begin']) > 0
            # contains_duration_type checks for duration of form XXXX-XX-XX/XXXX-XX-XX
            contains_duration_type2 = 'timex-value' in value and value['value'] == value['timex-value'] \
                                      and '/' in value['value'] and len(value['value']) == 21
            if value == {}:
                #print(question, ': DUCKLING')
                return get_duckling_result(question, input_columns, input_types)
            elif 'timex-value' in value:
                # Converting XXXX-XX-XX/XXXX-XX-XX into a standardized range format
                if contains_duration_type2:
                    c_value = value['value']
                    text = value['text'].lower()
                    dates = c_value.split('/')
                    date1 = dates[0]
                    date2 = dates[1]

                    if 'year' in text:
                        contains_range = True
                        year1 = date1.split('-')[0]
                        year2 = date2.split('-')[0]
                        combined_intersect += ' RANGE ' + year1 + 'TO' + year2
                        combined_values += ' RANGE ' + year1 + 'TO' + year2
                    elif 'quarter' in text:
                        date1 = datetime.strptime(str(date1), '%Y-%m-%d')
                        date2 = datetime.strptime(str(date2), '%Y-%m-%d')
                        if date2 < date1:
                            tmp = date1
                            date1 = date2
                            date2 = tmp
                        num_months = (date2.year - date1.year) * 12 + (date2.month - date1.month)
                        quarters = int(num_months/3)
                        val = 'PREV P' + str(quarters) + 'Q'
                        combined_intersect += val + ' INTERSECT '
                        combined_values += val + ' '
                    elif 'month' in text:
                        date1 = datetime.strptime(str(date1), '%Y-%m-%d')
                        date2 = datetime.strptime(str(date2), '%Y-%m-%d')

                        if date2 < date1:
                            tmp = date1
                            date1 = date2
                            date2 = tmp
                        num_months = (date2.year - date1.year) * 12 + (date2.month - date1.month)
                        val = 'PREV P' + str(num_months) + 'M'
                        combined_intersect += val + ' INTERSECT '
                        combined_values += val + ' '
                    elif 'week' in text:
                        date1 = datetime.strptime(str(date1), '%Y-%m-%d')
                        date2 = datetime.strptime(str(date2), '%Y-%m-%d')
                        days = abs((date1 - date2).days)
                        weeks = int(days/7)
                        val = 'PREV P' + str(weeks) + 'W'
                        combined_intersect += val + ' INTERSECT '
                        combined_values += val + ' '
                else:
                    c_value = value['timex-value']
                    combined_intersect += c_value + ' INTERSECT '
                    combined_values += c_value + ' '
            elif 'timex-value' not in value:
                c_value = value['value']
                if c_value == {}:
                    #print(question, ': DUCKLING')
                    return get_duckling_result(question, input_columns, input_types)
                elif contains_duration:
                    # Convert { 'end': XXXX-XX, 'begin': XXXX-XX } into standardized range format
                    if combined_intersect.endswith(' INTERSECT '):
                        combined_intersect = combined_intersect[:-len(' INTERSECT ')]
                    combined_values = combined_values.strip()
                    contains_range = True
                    if len(c_value['begin']) == 4 and len(c_value['end']) == 4 \
                        and c_value['begin'].isdigit() and c_value['begin'].isdigit():
                        combined_intersect += ' RANGE ' + c_value['begin'] + 'TO' + c_value['end'] + ' '
                        combined_values += ' RANGE ' + c_value['begin'] + 'TO' + c_value['end'] + ' '
                    elif len(c_value['begin']) == 7 and len(c_value['end']) == 7:
                        begin_dash_split = c_value['begin'].split('-')
                        end_dash_split = c_value['end'].split('-')
                        if begin_dash_split[0] == 'XXXX' and end_dash_split[0] == 'XXXX' \
                                and begin_dash_split[1].isdigit() and end_dash_split[1].isdigit():
                            combined_intersect += ' MRANGE ' + begin_dash_split[1] + 'TO' + end_dash_split[1] + ' '
                            combined_values += ' MRANGE ' + begin_dash_split[1] + 'TO' + end_dash_split[1] + ' '
                    elif len(c_value['begin']) == 10 and len(c_value['end']) == 10:
                        begin_dash_split = c_value['begin'].split('-')
                        end_dash_split = c_value['end'].split('-')
                        if begin_dash_split[0] == 'XXXX' and end_dash_split[0] == 'XXXX' \
                                and begin_dash_split[1].isdigit() and end_dash_split[1].isdigit() \
                                and begin_dash_split[2].isdigit() and end_dash_split[2].isdigit():
                            combined_intersect += ' DRANGE ' + begin_dash_split[1] + '-' + begin_dash_split[2]\
                                                  + 'TO' + end_dash_split[1] + '-' + end_dash_split[2] + ' '
                            combined_values += ' DRANGE ' + begin_dash_split[1] + '-' + begin_dash_split[2]\
                                               + 'TO' + end_dash_split[1] + '-' + end_dash_split[2] + ' '

                else:
                    combined_intersect += c_value + ' INTERSECT '
                    combined_values += c_value + ' '
    elif len(sutime_value) == 1:
        if type(sutime_value[0]['value']) is not dict:
            # Parsing and checking whether P3M, P6M refers to month or quarters
            is_quarter = re.search("(P\\d{1,2}M([^-]|$))", sutime_value[0]['value']) \
                         and 'quarter' in sutime_value[0]['text'].lower()
            if is_quarter:
                p_x_m = re.search("(P\\d{1,2}M([^-]|$))", sutime_value[0]['value']).group(1).strip()
                month = int(re.search(r'\d+', p_x_m).group())
                if month % 3 == 0:
                    quarter = int(month / 3)
                    val = 'P' + str(quarter) + 'Q'
                    sutime_value[0]['value'] = sutime_value[0]['value'].replace(p_x_m, val)
        if sutime_value[0]['value'] == {}:
            #print(question, ': DUCKLING')
            return get_duckling_result(question, input_columns, input_types)
        is_duration = type(sutime_value[0]['value']) is dict and sutime_value[0]['value'] != {}
        if is_duration:
            if 'begin' not in sutime_value[0]['value'] or 'end' not in sutime_value[0]['value']:
                #print(question, ': DUCKLING')
                return get_duckling_result(question, input_columns, input_types)
        # Check if response contains a range in form of { 'end': XXXX-XX, 'begin': XXXX-XX }
        len_1_contains_duration = type(sutime_value[0]['value']) is dict and sutime_value[0]['value'] != {} \
                        and len(sutime_value[0]['value']['end']) > 0 and len(sutime_value[0]['value']['begin']) > 0

        if 'timex-value' in sutime_value[0] and not len_1_contains_duration:
            c_value = sutime_value[0]['timex-value']
            combined_intersect = c_value
            combined_values = c_value
            c_value_split = c_value.split('-')
            if len(c_value_split) > 1:
                if c_value.split('-')[1] == 'WE' or c_value.split('-')[1] == 'WD':
                    week_subset = True
        elif 'timex-value' not in sutime_value[0] and not len_1_contains_duration:
            c_value = sutime_value[0]['value']
            if sutime_value[0] == {}:
                #print(question, ': DUCKLING')
                return get_duckling_result(question, input_columns, input_types)
            else:
                combined_intersect = c_value
                combined_values = c_value
    if not len_1_contains_duration:
        if combined_intersect.endswith(' INTERSECT '):
            combined_intersect = combined_intersect[:-len(' INTERSECT ')]
        combined_values = combined_values.strip()
        combined_intersect = combined_intersect.strip()
        combined_values = combined_values.strip()

    # print('After processing: ', sutime_value)
    # print(combined_values)
    # print(combined_intersect)
    #print(combined_intersect)
    # Currently not handling OFFSET keyword
    if 'OFFSET' in combined_values:
        return 'NAN'
    intersect_flag = 'INTERSECT' in combined_values or 'P' in combined_values or 'W' in combined_values \
                     or 'RANGE' in combined_values or 'PAST_REF' in combined_values or 'PRESENT_REF' in combined_values \
                     or 'THIS' in combined_values or 'PREV_IMMEDIATE' in combined_values or 'PREV' in combined_values
    prev_flag = 'PAST_REF' in combined_values or 'PRESENT_REF' in combined_values \
                or 'THIS' in combined_values or 'PREV_IMMEDIATE' in combined_values or 'PREV' in combined_values

    send_to_intersect = False
    lengths = []
    if not intersect_flag:
        combined_values_split = combined_values.split(' ')
        for value in combined_values_split:
            lengths.append(len(value))

    lengths = list(set(lengths))
    if len(lengths) > 1:
        if 4 in lengths:
            send_to_intersect = True
            # print('SEND TO INTERSECT: ', send_to_intersect)

    if intersect_flag or send_to_intersect or flag_dayofweek or week_subset or month_subset:
        d_response = d.parse_time(question)
        # print(len(d_response))
        # Use duckling if duckling response is len 1 or if sutime_parse_intersect gives bad response
        print(d_response)
        if len(d_response) > 1 or contains_range or prev_flag or flag_dayofweek or week_subset or month_subset:
            # print(prev_flag)

            result = sutime_parse_intersect(combined_intersect, input_columns, input_types, month_subset)
            
            if result == 'NAN' or result == '':
                # print(question, ': DUCKLING')
                return get_duckling_result(question, input_columns, input_types)
            else:
                # print(question, ": SUTIME INTERSECT")
                return result
        else:
            # print(question, ': DUCKLING')

            return get_duckling_result(question, input_columns, input_types)

    if len(sutime_value) == 1 and type(sutime_value[0]['value']) is not dict:
        if len(sutime_value[0]['value'].split(' ')) == 1 and 'XXXX' in sutime_value[0]['value']:
            if 'timex-value' in sutime_value[0]:
                sutime_value[0]['timex-value'] = sutime_value[0]['timex-value']\
                    .replace('XXXX', str(datetime.now().year))
                sutime_value[0]['value'] = sutime_value[0]['timex-value']
            else:
                sutime_value[0]['value'] = sutime_value[0]['value'].replace('XXXX', str(datetime.now().year))

    years = []
    for value in sutime_value:
        if type(value['value']) != dict and value['value'][:4].isdigit():
            years.append(value['value'][:4])
    
    if len(sutime_value) > 1:
        for value in sutime_value:
            if len(years) == 0:
                if type(value['value']) != dict and 'XXXX' in value['value']:
                    value['value'] = value['value'].replace('XXXX', str(datetime.now().year))
                    if 'timex-value' in value:
                        value['timex-value'] = value['timex-value'].replace('XXXX', str(datetime.now().year))
            else:
                if type(value['value']) != dict and 'XXXX' in value['value']:
                    value['value'] = value['value'].replace('XXXX', years[0])
                    if 'timex-value' in value:
                        value['timex-value'] = value['timex-value'].replace('XXXX', years[0])
            

    # print('Before going to vanilla sutime', sutime_value)
    # Parsing sutime response if simple format (no intersects)
    for time_val in sutime_value:
        if time_val['value'] == {}:
            #print(question, ': DUCKLING')
            return get_duckling_result(question, input_columns, input_types)

        # TODO: get rid of following checks - Already handled above
        contains_duration = type(time_val['value']) is dict and time_val['value'] != {} \
                            and len(time_val['value']['end']) > 0 and len(time_val['value']['begin']) > 0
        contains_bad_format = False
        if not contains_duration:
            contains_bad_format = len(time_val['value']) > 0 and 'OFFSET' in time_val['value'] or\
                                time_val['value'][0] == 'P' or 'INTERSECT' in time_val['value']\
                                or ('X' in time_val['value']) or \
                                ('W' in time_val['value'] and (time_val['value'].split('W')[1]).isdigit())
        #print('GETTING HERE: ', contains_bad_format)
        if contains_bad_format:
            #print(question, ': DUCKLING')
            return get_duckling_result(question, input_columns, input_types)
        else:
            #if first:
                #print(question, ": SUTIME")
            first = False

            if contains_duration:
                begin = time_val['value']['begin']
                begin_split = begin.split('-')
                end = time_val['value']['end']

                if len(begin_split) == 1:
                    begin_split = begin.split('-')
                    end_split = end.split('-')
                    if begin_split[0] == 'XXXX' and end_split[0] != 'XXXX':
                        begin_split[0] = end_split[0]
                    elif begin_split[0] != 'XXXX' and end_split[0] == 'XXXX':
                        end_split[0] = begin_split[0]
                    elif begin_split[0] == 'XXXX' and end_split[0] == 'XXXX':
                        begin_split[0] = begin_split[0].replace('XXXX', str(datetime.now().year))
                        end_split[0] = end_split[0].replace('XXXX', str(datetime.now().year))
                    begin = '-'.join(begin_split)
                    end = '-'.join(end_split)
                    if len(end_split) == 1:
                        col_name = input_columns[input_types.index('year')]
                        condition = col_name + ' BETWEEN \'' + begin_split[0] + '\' AND \'' + end_split[0] + '\''
                        conditions.append(condition)
                    elif len(end_split) == 2:
                        col_name = input_columns[input_types.index('date')]
                        begin += '-01-01'
                        end += '-' + str(calendar.monthrange(int(end_split[0]), int(end_split[1]))[1])
                        condition = col_name + ' BETWEEN \'' + begin + '\' AND \'' + end + '\''
                        conditions.append(condition)
                    elif len(end_split) == 3:
                        col_name = input_columns[input_types.index('date')]
                        begin += '-01-01'
                        condition = col_name + ' BETWEEN \'' + begin + '\' AND \'' + end + '\''
                        conditions.append(condition)

                elif len(begin_split) == 2:
                    col_name = input_columns[input_types.index('date')]
                    begin += '-01'
                    begin_split = begin.split('-')
                    end_split = end.split('-')

                    if begin_split[0] == 'XXXX' and end_split[0] != 'XXXX':
                        begin_split[0] = end_split[0]

                    elif begin_split[0] != 'XXXX' and end_split[0] == 'XXXX':
                        end_split[0] = begin_split[0]
                    elif begin_split[0] == 'XXXX' and end_split[0] == 'XXXX':
                        begin_split[0] = begin_split[0].replace('XXXX', str(datetime.now().year))
                        end_split[0] = end_split[0].replace('XXXX', str(datetime.now().year))
                    begin = '-'.join(begin_split)
                    end = '-'.join(end_split)
                    if len(end_split) == 1:
                        end += '-' + begin_split[1] + '-' + begin_split[2]
                        condition = col_name + ' BETWEEN \'' + begin + '\' AND \'' + end + '\''
                        conditions.append(condition)
                    elif len(end_split) == 2:
                        if 'Q' not in begin and 'Q' not in end:
                            end += '-' + str(calendar.monthrange(int(end_split[0]), int(end_split[1]))[1])
                            condition = col_name + ' BETWEEN \'' + begin + '\' AND \'' + end + '\''
                            conditions.append(condition)
                        elif 'Q' in begin and 'Q' in end:
                            # print(sutime_value)
                            # print(begin)
                            # print(end)
                            quarter1 = int(begin_split[1][1])
                            year1 = int(begin_split[0])
                            quarter2 = int(end_split[1][1])
                            year2 = int(end_split[0])
                            month1 = (quarter1 * 3) - 2
                            month2 = (quarter2 * 3)
                            end_day = calendar.monthrange(int(year2), int(month2))[1]
                            begin_date = datetime.strftime(datetime(year1, month1, 1), '%Y-%m-%d')
                            end_date = datetime.strftime(datetime(year2, month2, end_day), '%Y-%m-%d')
                            condition = col_name + ' BETWEEN \'' + begin_date + '\' AND \'' + end_date + '\''
                            conditions.append(condition)
                    elif len(end_split) == 3:
                        condition = col_name + ' BETWEEN \'' + begin + '\' AND \'' + end + '\''
                        conditions.append(condition)

                elif len(begin_split) == 3:
                    col_name = input_columns[input_types.index('date')]
                    begin_split = begin.split('-')
                    end_split = end.split('-')

                    if begin_split[0] == 'XXXX' and end_split[0] != 'XXXX':
                        begin_split[0] = end_split[0]
                        #print('begin ', begin_split)
                    elif begin_split[0] != 'XXXX' and end_split[0] == 'XXXX':
                        end_split[0] = begin_split[0]
                    elif begin_split[0] == 'XXXX' and end_split[0] == 'XXXX':
                        begin_split[0] = begin_split[0].replace('XXXX', str(datetime.now().year))
                        end_split[0] = end_split[0].replace('XXXX', str(datetime.now().year))
                    begin = '-'.join(begin_split)
                    end = '-'.join(end_split)

                    if len(end_split) == 1:
                        end += '-' + begin_split[1] + '-' + begin_split[2]
                        condition = col_name + ' BETWEEN \'' + begin + '\' AND \'' + end + '\''
                        conditions.append(condition)
                    elif len(end_split) == 2:
                        end += '-' + str(calendar.monthrange(int(end_split[0]), int(end_split[1]))[1])
                        condition = col_name + ' BETWEEN \'' + begin + '\' AND \'' + end + '\''
                        conditions.append(condition)
                    elif len(end_split) == 3:
                        condition = col_name + ' BETWEEN \'' + begin + '\' AND \'' + end + '\''
                        conditions.append(condition)

            if not contains_duration:
                values = time_val['timex-value'].split('/')
                if len(values) > 1:
                    from_date = values[0]
                    to_date = values[1]
                    to_date_dt = datetime.strptime(str(to_date), '%Y-%m-%d') - timedelta(days=1)
                    to_date_str = datetime.strftime(to_date_dt, '%Y-%m-%d')
                    # Assume question being asked is 'last n weeks/months/years'
                    if 'date' in input_types:
                        col_name = input_columns[input_types.index('date')]
                        condition = col_name + ' BETWEEN \'' + from_date + '\' AND \'' + to_date_str + '\''
                        conditions.append(condition)
                    elif 'year' in input_types and 'month' in input_types:
                        month_col_name = input_columns[input_types.index('month')]
                        year_col_name = input_columns[input_types.index('year')]
                        year1 = from_date.split('-')[0]
                        year2 = to_date.split('-')[0]
                        month1 = from_date.split('-')[1]
                        month2 = to_date.split('-')[1]
                        if year1 == year2:
                            condition = month_col_name + ' >= \'' + month1 + '\' AND ' + month_col_name + \
                                        ' <= \'' + month2 + '\' AND ' + year_col_name + ' = \'' + year1 + '\')'
                        else:
                            condition = '(' + month_col_name + ' >= \'' + month1 + '\' AND ' + year_col_name + ' = \'' + year1 + \
                                      '\') OR (' + month_col_name + ' <= \'' + month2 + '\' AND ' + year_col_name + ' = \'' + year2 + '\') ' \
                                     'OR (' + year_col_name + ' BETWEEN \'' + str(int(year1) + 1) + '\' AND \'' + str(int(year2) - 1) + '\')'
                        conditions.append(condition)
                    elif 'year' in input_types and 'month' not in input_types:
                        col_name = input_columns[input_types.index('year')]
                        year1 = from_date.split('-')[0]
                        year2 = to_date.split('-')[0]
                        if year1 == year2:
                            condition = col_name + ' = \'' + year1 + '\''
                        else:
                            condition = col_name + ' BETWEEN \'' + year1 + '\' AND \'' + year2 + '\''
                        conditions.append(condition)
                else:
                    values = time_val['timex-value'].split('-')
                    if len(values) == 3:
                        week_days = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]
                        if time_val['text'].lower() in week_days:
                            today = datetime.now()
                            today = datetime(today.year, today.month, today.day)
                            if today <= datetime(int(values[0]), int(values[1]), int(values[2])):
                                offset = today.weekday() - week_days.index(time_val['text'].lower())
                                if offset <= 0:
                                    last_weekday = today - timedelta(days=7 + offset)
                                    time_val['timex-value'] = datetime.strftime(last_weekday, '%Y-%m-%d')
                                    #print('IF!')
                                else:
                                    last_weekday = today - timedelta(days=offset)
                                    time_val['timex-value'] = datetime.strftime(last_weekday, '%Y-%m-%d')
                                    #print('IF#')
                        col_name = input_columns[input_types.index('date')]
                        condition = col_name + ' = \'' + time_val['timex-value'] + '\''
                        conditions.append(condition)
                    elif len(values) == 2:
                        col_name1 = input_columns[input_types.index('year')]
                        date_col = input_columns[input_types.index('date')]
                        quarter_col = input_columns[input_types.index('quarter')]
                        if 'Q' in values[1]:
                            q_num = values[1][1]
                            year = values[0]
                            condition = quarter_col + ' = \'' + q_num + '\' AND ' + col_name1 + ' = \'' + year + '\''
                            conditions.append(condition)
                        else:
                            col_name = input_columns[input_types.index('month')]
                            condition = col_name1 + ' = \'' + values[0] + '\''
                            condition += ' AND ' + col_name + ' = \'' + values[1] + '\''
                            conditions.append(condition)
                    elif len(values) == 1:
                        col_name = input_columns[input_types.index('year')]
                        condition = col_name + ' = \'' + values[-1] + '\''
                        conditions.append(condition)

    output_condition = ''
    if len(conditions) > 1:
        for i in range(len(conditions)):
            if i != len(conditions)-1:
                output_condition += '(' + conditions[i] + ')' + ' OR '
            else:
                output_condition += '(' + conditions[i] + ')'
    elif len(conditions) == 0:
        return 'NAN'
    else:
        output_condition = conditions[0]

    return output_condition

def prune_condition(input_columns, input_date_types, dummy_input_columns, dummy_input_date_types, not_in_date_types, condition):
    contains_date = dummy_input_columns[dummy_input_date_types.index('date')]+' ' in condition
    contains_year = dummy_input_columns[dummy_input_date_types.index('year')]+' ' in condition
    contains_month = dummy_input_columns[dummy_input_date_types.index('month')]+' ' in condition
    contains_week = dummy_input_columns[dummy_input_date_types.index('week')]+' ' in condition
    contains_day = dummy_input_columns[dummy_input_date_types.index('day_name')]+' ' in condition
    contains_quarter = dummy_input_columns[dummy_input_date_types.index('quarter')]+' ' in condition

    # Dataset only contains month as date col
    if len(not_in_date_types) == 5 and 'month' in input_date_types:
        if contains_month and contains_year:
            condition = re.sub(dummy_input_columns[dummy_input_date_types.index('year')] + ' = ' + "'\d{4}'","",condition)
            condition = condition.replace(' AND ', '')
        elif contains_date:
            if 'BETWEEN' in condition:
                dates = re.findall('\d{4}-\d{2}-\d{2}',condition)
                month_col = dummy_input_columns[dummy_input_date_types.index('month')]
                condition = ''
                months = []
                for date in dates:
                    months.append(str(datetime.strptime(date, '%Y-%m-%d').month))
                pairs = []
                for i in range(0,len(months),2):
                    pairs.append(f"({month_col} BETWEEN '{months[i]}' AND '{months[i+1]}')")
                condition = ' OR '.join(pairs)
            else:
                dates = re.findall('\d{4}-\d{2}-\d{2}',condition)
                ops = re.findall('=|>|<',condition)
                month_col = dummy_input_columns[dummy_input_date_types.index('month')]
                condition = ''
                months = []
                for i in range(len(dates)):
                    months.append(f"({month_col} {ops[i]} '{str(datetime.strptime(dates[i], '%Y-%m-%d').month)}')")
                condition = ' OR '.join(months)


    # Dataset contains year and month as date col
    elif len(not_in_date_types) == 4 and 'month' in input_date_types and 'year' in input_date_types:
        if 'Date' in condition:
            condition = condition.replace("'","")
            condition_splt = condition.split(' ')
            month_col = input_columns[input_date_types.index('month')]
            year_col = input_columns[input_date_types.index('year')]
            if len(condition_splt) == 3 and condition_splt[0] == 'Date':
                sign = condition_splt[1]
                date_splt = condition_splt[2].split('-')
                month = date_splt[1]
                year = date_splt[0]
                condition = f"({month_col} {sign} '{month}' AND {year_col} = '{year}') OR ({year_col} {sign} '{year}')"
            elif len(condition_splt) == 5 and 'BETWEEN in condition':
                date1_split = condition_splt[2].split('-')
                date2_split = condition_splt[4].split('-')
                month1 = date1_split[1]
                month2 = date2_split[1]
                year1 = int(date1_split[0])
                year2 = int(date2_split[0])
                if year2 == year1:
                    condition = f"({month_col} BETWEEN '{month1}' AND '{month2}') AND ({year_col} = '{year1}')"
                elif year2 - year1 == 1:
                    condition = f"({month_col} > '{month1}' AND {year_col} = '{str(year1)}') OR ({month_col} < '{month2}' AND {year_col} = '{str(year2)}')"
                elif year2 - year1 == 2:
                    condition = f"({month_col} > '{month1}' AND {year_col} = '{str(year1)}') OR ({month_col} < '{month2}' AND {year_col} = '{str(year2)}') OR ({year_col} = '{str(year1+1)}'')"
                else:
                    condition = f"({month_col} > '{month1}' AND {year_col} = '{str(year1)}') OR ({month_col} < '{month2}' AND {year_col} = '{str(year2)}') OR ({year_col} BETWEEN '{str(year1+1)}' AND '{str(year2-1)}')"
    condition = condition.replace("()",'')
    return f"({condition})"
    
def get_dummy_columns(input_columns, input_date_types):
    all_date_types = ['date', 'year', 'month', 'week', 'day_name', 'quarter']
    all_date_columns = ['Date', 'Date_Year', 'Date_Month', 'Date_Week', 'Date_Day_Name', 'Date_Quarter']

    dummy_input_columns, dummy_input_date_types = input_columns.copy(), input_date_types.copy()

    not_in_date_types = set(all_date_types) - set(input_date_types)
    
    for typ in not_in_date_types:
        dummy_input_columns.append(all_date_columns[all_date_types.index(typ)])
        dummy_input_date_types.append(typ)
    
    return dummy_input_columns, dummy_input_date_types, not_in_date_types

def gen_date_conditions(question, input_columns, input_types, remove_tokens=None):
    """This function calls other internal functions and return the date conditions
               Args:
                    question: String
                        NL question with dates to convert to conditions

                    input_columns: List
                        Columns to select from the database (Date, month, year, quarter, etc...)

                    input_types: List
                        Column types of the input_columns (one-to-one mapping with input_columns list)
                        Ex:input_types = ['date', 'month', 'year', 'quarter', 'week']

                    remove_tokens: List
                        Tokens to be removed from NL question (model has already used for conditions)
                        default None

               Returns:
                    response: String
                        String of date conditions based on NL question

        """
    response = ''

    
    c_year = str(datetime.now().year)
    next_year = str(datetime.now().year + 1)
    # try:
    dummy_input_columns, dummy_input_types, not_in_date_types = get_dummy_columns(input_columns, input_types)
    date_cond_result = date_condition(question, dummy_input_columns, dummy_input_types, remove_tokens)
    date_cond_result = date_cond_result.replace(next_year, c_year)
    date_cond_result = prune_condition(input_columns, input_types, dummy_input_columns, dummy_input_types, not_in_date_types, date_cond_result)
    return date_cond_result


def write_results(results_file, new_col_name, input_columns, input_types):
    result_df = pd.read_excel(results_file)
    result_dict = {'questions': result_df['questions'], 'conditions': []}
    for question in result_dict['questions']:
        result_dict['conditions'].append(gen_date_conditions(question, input_columns, input_types))

    result_df[new_col_name] = result_dict['conditions']
    result_df.to_excel(results_file, index=False)


def cross_validate(results_file, col_name_compare, input_columns, input_types):
    orig_df = pd.read_excel(results_file)
    orig_df = orig_df[['questions', col_name_compare]]
    result_dict = {'questions': orig_df['questions'], 'conditions': []}

    for question in result_dict['questions']:
        result_dict['conditions'].append(gen_date_conditions(question, input_columns, input_types))

    result_df = pd.DataFrame.from_dict(result_dict)

    true_idx = orig_df[col_name_compare] != result_df.conditions

    merged_df = pd.merge(orig_df, result_df, left_index=True, right_index=True)

    difference = merged_df[true_idx]
    difference.to_excel('differences.xlsx', index=False)


# testcases = ['May I have the revenue for January?',
#              'May I have the revenue for March?',
#              'What was the revenue in January and February?',
#              'May I have the revenue for April, May and July?',
#              'May I have the revenue for December 2019, January 2018 and February 2015?',
#              'What was the revenue for the last two weeks?',
#              'what is revenue on the last day of previous month?',
#              'what is the revenue on the first day of the last month?',
#              'what was the revenue 2 months ago?',
#              'what was the revenue for the month 2 months ago?',
#              'what is the revenue generated on 2nd January 2020',
#              'what is the revenue generated this year?',
#              'What is the revenue generated on 2nd month of 2nd quarter?',
#              'What is the revenue generated for 2nd quarter',
#              'Last month what was the revenue generated?',
#              'How much did we earn a fortnight ago?',
#              'What was the revenue for past month?',
#              'What was the revenue for the last month?',
#              'What was the revenue for last month?',
#              'What was the revenue for the past month?',
#              'What was the revenue for past two months?',
#              'what is the revenue for the last quarter of 2019',
#              'What is the total revenue between January and March in 2019',
#              'give me the total revenue for john over the past 8 months',
#              'What is the total revenue for the last two quarters of 2010',
#              'what was revenue for first quarter of last year',
#              'What is the total revenue for the 2nd quarter of 2019?',
#              'what was the revenue in June July and August of 2019 and 2018',
#              'what was the revenue in second quarter of 2019 and 2018',
#              'who sales most amount of apple for the last two quarters ',
#              'Give me the profit for the past 6 weeks',
#              'show me all all salespersons who sold apple during previous week',
#              'what is the profit during second week of 4th month in 2019',
#              'give me the average profit for last 25 days',
#              'Since last month of 2019, how much is the total profit?',
#              'what is the revenue generated in 4th week of 3rd quarter for last year?',
#              'Give me the total revenue between 3rd quarter and of 2017 and 2nd quarter of 2018',
#              'who sold the highest amount of apple from 8th day of the second quarter of 2018 to first week of second month of 2019',
#              'what is the average revenue on January for 2018, 2019 and 2020',
#              'What is the revenue generated for March 24, 2019?',
#              'What is the revenue generated for 03/15/2019?',
#              'give me the profit for last 30 days for 2019 and 2018',
#              'what is the total revenue for the past 10 weeks',
#              'what is the profit for the 34th week of last year?',
#              'what is the revenue for 10 years ago',
#              'give me the revenue for the first week of q2 this year',
#              'How much was the profit for 1st week of January to 3rd week of August',
#              'what is the maximum revenue in the last two months?',
#              'In the first week of 11th month of last year, what was the total profit?',
#              'what is the average revenue on January for 2018, 2019 and 2020',
#              'what is the total revenue for year 2019 and 2018',
#              'who sold apple in canada between January and march? ',
#              'What is the revenue between the 2nd quarter of 2019 and 1st quarter of 2020?',
#              'what is the net income in April and May of 2019?',
#              'for the last 17 weeks of 2019 what is the profit?',
#              'what was the revenue in second quarter of 2019',
#              'tell me the name of the people who sold apple in last day of q2 in 2018?',
#              'Who sold most apples between January and March in 2019',
#              'what is the revenue generated between quarter 1 of 2019 and last month of 2020',
#              'Who sold most apples in the last 2 weeks of last 4 months of 2019?',
#              'what is the total profit in the 21st day of the second quarter of 2018 and 2019',
#              'what is the average revenue in the last 3 months of 2019 and 2018?',
#              'give me the revenue for the first two weeks of January',
#              'What is the profit of 4th day of second week of second month of second quarter in 2018?',
#              'who gain the maximum profit in the last quarter of 2010 and 2019?',
#              'what is the average revenue for second week of last quarter of 2019?',
#              'what is the total revenue on March, April and November 2018 and 2019?',
#              'give me the name of salespeople in first two quarters in 2018 and 2019',
#              'give me the revenue for this fiscal year?',
#              'Show me the day of second highest profit in the second week of third quarter of 2019',
#              ]
#
# input_columns = ['DATE', 'MONTH(DATE)', 'YEAR(DATE)', 'QUARTER(DATE)', 'WEEK(DATE)', 'DAY NAME']
# input_types = ['date', 'month', 'year', 'quarter', 'week', 'day_name']
#
# input_columns2 = ['MONTH(DATE)', 'YEAR(DATE)']
# input_types2 = ['month', 'year']
#
# input_columns3 = ['YEAR(DATE)']
# input_types3 = ['year']

# for test_case in testcases:
#     print(test_case)
#     print(gen_date_conditions(test_case, input_columns, input_types)+'\n')

# date_condition('What is the revenue for all weekends', input_columns, input_types)
# input1 = 'thursday for 3rd week for april 2017'
# input2 = ['ship_date', 'ship_date_day_name', 'ship_date_month', 'ship_date_year', 'ship_date_quarter', 'ship_date_week']
# input3 = ['date', 'day_name', 'month', 'year', 'quarter', 'week']
# print(gen_date_conditions(input1, input2, input3))
